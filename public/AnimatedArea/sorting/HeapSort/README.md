# 堆排序（Heap Sort）

堆排序是一种基于二叉堆数据结构的比较排序算法。它利用堆的性质进行排序，将输入序列构建成最大堆或最小堆，然后依次取出堆顶元素得到有序序列。

## 工作原理

堆排序分为两个主要阶段：

### 第一阶段：构建最大堆
1. 将无序数组视为一个完全二叉树
2. 从最后一个非叶子节点开始，逐个向上进行"堆化"（heapify）操作
3. 堆化操作确保每个父节点的值大于或等于其子节点的值
4. 完成后，根节点将包含数组中的最大值

### 第二阶段：依次提取最大元素
1. 将堆顶元素（最大值）与堆的最后一个元素交换
2. 将交换后的最后一个元素标记为已排序，不再参与堆化
3. 对剩余的堆进行堆化，恢复最大堆性质
4. 重复上述步骤，直到所有元素都被排序

## 堆化（Heapify）过程
1. 从当前节点开始，与其左右子节点比较
2. 找出三者中的最大值
3. 如果最大值不是当前节点，则交换它们
4. 交换后，被交换的子树可能违反堆的性质，需要递归地对该子树进行堆化

## 复杂度分析

| 时间复杂度（平均） | 时间复杂度（最坏） | 时间复杂度（最好） | 空间复杂度 | 稳定性 |
|-----------------|-----------------|-----------------|-----------|-------|
| O(n log n)      | O(n log n)      | O(n log n)      | O(1)      | 不稳定 |

<img src="/AnimatedArea/sorting/HeapSort/堆排序.png" alt="堆排序示意图" width="500px" />

## 堆排序的优缺点

### 优点
- 时间复杂度稳定，最坏情况下仍为O(n log n)
- 原地排序，不需要额外的存储空间
- 适用于大数据量排序

### 缺点
- 不稳定排序，相等元素的相对顺序可能改变
- 在实际应用中，常数因子较大，性能可能不如快速排序
- 对缓存不友好，因为堆是一个树结构，访问模式不连续

## 应用场景
- 需要保证最坏情况下时间复杂度的场景
- 实现优先队列
- 求解TopK问题（找出数组中最大或最小的K个元素）
- 需要原地排序且对空间敏感的场景

## 与其他排序算法的比较
- 相比快速排序：最坏情况下表现更好，但平均性能略差
- 相比归并排序：空间复杂度更低，但不稳定
- 相比冒泡、插入、选择排序：在大数据量下效率明显更高 