# 快速排序（Quick Sort）

快速排序是一种高效的分治排序算法，由Tony Hoare于1960年提出。它通过选择一个"基准"（pivot）元素，将数组分成两部分，一部分所有元素都小于基准，另一部分所有元素都大于基准，然后对这两部分递归地应用相同的过程。

## 工作原理

1. 选择一个基准元素（通常选择数组的最后一个元素）
2. 将数组分割（partition）：所有小于基准的元素移到基准前面，所有大于基准的元素移到基准后面
3. 基准元素放到最终位置
4. 递归地对基准前后的两个子数组应用上述步骤
5. 当子数组长度为0或1时，递归结束

## 分割（Partition）过程

1. 从数组的第一个元素开始，维护一个小于基准的元素区域的边界
2. 遍历数组，当遇到小于基准的元素时，将其与边界后的第一个元素交换，并扩大边界
3. 遍历完成后，将基准元素与边界后的第一个元素交换
4. 此时，基准元素左侧的元素都小于基准，右侧的元素都大于基准

## 复杂度分析

| 时间复杂度（平均） | 时间复杂度（最坏） | 时间复杂度（最好） | 空间复杂度 | 稳定性 |
|-----------------|-----------------|-----------------|-----------|-------|
| O(n log n)      | O(n²)           | O(n log n)      | O(log n)  | 不稳定 |

<img src="/AnimatedArea/sorting/QuickSort/快速排序.png" alt="快速排序示意图" width="500px" />

## 快速排序的优缺点

### 优点
- 平均情况下，是最快的通用排序算法之一
- 实际应用中通常比其他O(n log n)算法更快
- 原地排序，不需要额外的存储空间（递归调用栈除外）
- 缓存友好，适合现代计算机体系结构

### 缺点
- 不稳定排序，可能改变相等元素的相对顺序
- 在最坏情况下（已排序的数组）时间复杂度为O(n²)
- 对于小规模数据集，可能不如插入排序

## 应用场景
- 通用排序场景，尤其是大型数据集
- 很多编程语言的标准库排序实现
- 需要高性能排序的应用
- 数据访问成本高的情况（如外部存储）

## 优化方案
- 随机选择基准元素，避免最坏情况
- 三数取中（median-of-three）选择基准元素
- 对小规模子数组使用插入排序
- 尾递归优化，减少递归调用栈深度 