# 归并排序（Merge Sort）

归并排序是一种高效的、稳定的分治排序算法，由冯·诺依曼在1945年提出。它的基本思想是将数组分成两个较小的子数组，然后递归地对它们进行排序，最后将两个已排序的子数组合并成一个有序数组。

## 工作原理

归并排序遵循分治法（Divide and Conquer）策略，主要包括三个步骤：

1. **分割（Divide）**：将待排序数组分成两个大小相等（或相差一个元素）的子数组
2. **递归排序（Conquer）**：递归地对两个子数组分别进行排序
3. **合并（Merge）**：将两个已排序的子数组合并成一个有序数组

## 具体过程

### 分割阶段
1. 找到数组的中间位置，将其分为左右两个子数组
2. 对左侧子数组递归应用归并排序
3. 对右侧子数组递归应用归并排序

### 合并阶段
1. 创建临时数组存放合并结果
2. 同时遍历两个有序子数组，比较当前元素
3. 选择较小的元素放入临时数组，并移动该子数组的指针
4. 当一个子数组遍历完成后，将另一个子数组的剩余元素直接复制到临时数组
5. 将临时数组中的元素复制回原数组对应位置

## 复杂度分析

| 时间复杂度（平均） | 时间复杂度（最坏） | 时间复杂度（最好） | 空间复杂度 | 稳定性 |
|-----------------|-----------------|-----------------|-----------|-------|
| O(n log n)      | O(n log n)      | O(n log n)      | O(n)      | 稳定   |

<img src="/AnimatedArea/sorting/MergeSort/归并排序.png" alt="归并排序示意图" width="500px" />

## 归并排序的优缺点

### 优点
- 稳定排序，保持相等元素的相对顺序
- 时间复杂度在最好、平均和最坏情况下都是O(n log n)，性能稳定
- 适合处理大型数据集
- 适合外部排序，对磁盘等外部存储设备友好

### 缺点
- 需要额外O(n)的空间来存储临时数组
- 对于小规模数据，可能不如插入排序等简单算法高效
- 在原地实现上较为复杂

## 应用场景
- 需要稳定排序的场景
- 外部排序，当数据量太大无法全部加载到内存中时
- 需要保证排序时间复杂度为O(n log n)的场景
- 对时间复杂度的稳定性有高要求的场景

## 与其他排序算法的比较
- 相比快速排序：更稳定，最坏情况下表现更好，但通常空间复杂度较高
- 相比堆排序：稳定性更好，但空间复杂度较高
- 相比插入排序：大数据集上效率更高，但实现更复杂且需要额外空间

## 进阶优化
- 对小规模子数组使用插入排序（混合排序策略）
- 在合并前检查是否已经有序，避免不必要的合并操作
- 使用循环实现而非递归，减少函数调用开销 